Ответы нужно давать лаконичные, достаточно продемонстрировать понимание предмета.
Ф.И.О.
Java
1. Что такое переопределение метода?
Один из инструментов для реализации идеи полиморфизма.
Переопределение метода (англ. Method overriding) в ООП — одна из возможностей языка программирования,
позволяющая подклассу или дочернему классу обеспечивать специфическую реализацию метода,
уже реализованного в одном из суперклассов или родительских классов.

2. Какие бывают виды классов?
Обычный класс - шаблонная конструкция, которая позволяет описать в программе объект, его свойства (поля класса) и поведение (методы класса).
Абстрактный класс - нельзя создать объект или экземпляр абстрактного класса;
Финализированный класс - не поддается наследованию и все его методы косвенным образом приобретают свойство final.
Вложенный класс:
- Статический вложенный класс – статические классы внутри внешнего класса;
- Простой внутренний класс – нестатические классы внутри внешнего класса;
- Локальный класс – классы внутри методов;
- Анонимный класс – классы, которые создаются на ходу.

3. Как и зачем можно использовать модификатор final?
Final может применяться к классам, методам, переменным (в том числе аргументам методов).
- Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование.
Это полезно при создании immutable (неизменяемых) объектов, например, класс String объявлен, как final.
Следует также отметить, что к абстрактным классам (с ключевым словом abstract), нельзя применить модификатор final, т.к. это взаимоисключающие понятия.
- Для метода final означает, что он не может быть переопределен в подклассах.
Это полезно, когда мы хотим, чтобы исходную реализацию нельзя было переопределить.
- Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено.
- Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект.
Ссылку изменить нельзя, но состояние объекта изменять можно.

4. Какие есть варианты использования ключевого слова try?
Try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.

5. Какие есть стандартные реализации интерфейса List и в каких ситуациях их нужно использовать?
Интерфейс List сохраняет последовательность добавления элементов и позволяет осуществлять доступ к элементу по индексу.
Одной из реализаций интерфейса List является класс ArrayList. Он поддерживает динамические массивы, которые могут расти по мере необходимости.
Элементы ArrayList могут быть абсолютно любых типов, в том числе и null. Элементы в этом виде коллекции могут повторяться.
Данный класс используется чаще всех остальных реализаций коллекции.
Достоинства класса ArrayList:
- Быстрый доступ по индексу. Скорость такой операции  - O(1).
- Быстрая вставка и удаление элементов с конца. Скорость операций опять же - O(1).

6. В чём основная идея стримов из пакета java.util.stream?
Стрим — это объект для универсальной работы с данными.
И это вовсе не какая-то новая структура данных, он использует существующие коллекции для получения новых элементов.
Затем к данным применяются методы. В интерфейсе Stream их множество. Каждый выполняет одну из типичных операций с коллекцией:
отсортировать, перегруппировать, отфильтровать.
Стримы избавляют программистов от написания стереотипного кода всякий раз, когда нужно сделать что-то с набором элементов.
То есть благодаря стримам не приходится думать о деталях реализации.

Разное
7. Каким критериям должна удовлетворять «хорошая» хэш-функция?
Хеш-функция - это математический алгоритм, который отображает данные произвольного размера в битовый массив фиксированного размера.
Результат, производимый хеш-функцией, называется «хеш-суммой» или же просто «хешем», а входные данные часто называют «сообщением».
Для идеальной хеш-функции выполняются следующие условия:
- хеш-функция является детерминированной, то есть одно и то же сообщение приводит к одному и тому же хеш-значению
- значение хеш-функции быстро вычисляется для любого сообщения
- невозможно найти сообщение, которое дает заданное хеш-значение
- невозможно найти два разных сообщения с одинаковым хеш-значением
- небольшое изменение в сообщении изменяет хеш настолько сильно, что новое и старое значения кажутся некоррелирующими

8. В чём причина популярности и широкого распространения кодировки UTF-8?
UTF-8 — распространённый стандарт кодирования символов, позволяющий более компактно хранить и передавать символы Юникода,
используя переменное количество байт (от 1 до 4), и обеспечивающий полную обратную совместимость с 7-битной кодировкой ASCII.
Кодировка UTF-8 сейчас является доминирующей в веб-пространстве. Она также нашла широкое применение в UNIX-подобных операционных системах.
Один из главных аргументов связан с тем, что UTF-8 сокращает объем памяти, занимаемый символами на латинице (их использует множество языков программирования).
Латинские буквы, цифры и распространенные знаки препинания кодируются в UTF-8 лишь одним байтом.
При этом их коды соответствует кодам в ASCII, что дает обратную совместимость.

9. Сравните форматы XML и JSON. Когда какой использовать?
1. JSON расшифровывается как JavaScript Object Notation. Это текстовый открытый стандартный формат обмена данными.
JSON легкий и легко читаемый, но не предоставляет схем или информации о типах. Он отлично подходит для обмена данными между несколькими приложениями.
XML означает расширяемый язык разметки. Это язык разметки, который определяет структуру любого файла XML в виде древовидной структуры.
Его можно использовать для обмена структурированной информацией между программами и документами.

2. JSON и XML - популярные способы хранения структурированных данных в файле или базе данных. JSON - это легкий, читаемый человеком способ представления структур данных,
в то время как код XML - более объемный способ представления структурированных данных.

3. Одно из ключевых различий между этими двумя форматами данных заключается в том, что JSON может использоваться с JavaScript или обычными текстовыми файлами,
в то время как XML может храниться только в виде текстового файла. Кроме того, при обработке информации JSON использует меньше памяти, чем программа XML.
Эти ключевые различия в использовании памяти делают JSON идеальным форматом для быстрой обработки больших объемов данных.

4. Формат JSON - это способ компактного хранения данных, чтобы программы могли их прочитать. Как правило, его легче писать и читать, чем XML, поскольку в нем используется меньше символов.
В то же время формат данных XML - это особая форма языка разметки для хранения данных в организованном виде. У него больше возможностей, чем у JSON, но он также сложнее,
поскольку требует больше информации о структуре документа, прежде чем его можно будет прочитать.

5. Формат JSON используется для хранения и передачи данных, а XML - для представления данных в машиночитаемом виде.
JSON набирает популярность как средство хранения данных для веб-приложений благодаря своей простоте.
В отличие от него, XML все еще используется для передачи структурированных данных через Интернет.

6. Одно из ключевых различий между этими двумя форматами данных заключается в том, что JSON, как правило, более компактен, чем XML,
а значит, его можно быстрее передавать по сетям. JSON также имеет меньше ограничений на структуру, что помогает программистам при попытке разобрать большой объем данных.
Кроме того, многие языки программирования поддерживают оба формата, поэтому нет необходимости переключаться между ними при работе с разными платформами или языками программирования.

7. Вы можете использовать JSON в своем веб-приложении или мобильном приложении, не беспокоясь о проблемах совместимости, поскольку он широко распространен в веб- и мобильных приложениях.
С другой стороны, XML имеет некоторые проблемы, когда речь идет о кросс-платформенной совместимости. Он не поддерживается многими языками программирования (кроме Actionscript),
поэтому разработчикам приходится выбирать между использованием таких инструментов, как Apache HttpComponents или Apache axis2, если они хотят,
чтобы их приложения работали на нескольких платформах одновременно.

8. XML файлы требуют больше места для хранения, чем файлы JSON (по крайней мере, если вы используете их с Node). В целом, это не является проблемой,
если на вашем веб-сервере достаточно оперативной памяти для хранения этих файлов; в противном случае вам следует подумать об изменении архитектуры вашего приложения,
чтобы вся обработка происходила на стороне клиента, а не за кулисами, где она будет занимать слишком много места в памяти.

9. Одно из ключевых различий между JSON и XML заключается в том, что XML имеет более жесткую структуру, чем JSON, что делает его более сложным для манипуляций без разрушения документа.
Кроме того, большинство файлов XML нельзя редактировать в месте, как это делают документы JSON; поэтому, если вы хотите изменить значение элемента в документе JSON,
вы можете отредактировать значение непосредственно в текстовом редакторе, и дело сделано. Это означает, что злоумышленник может изменить значение элемента,
просто отредактировав сам документ, и это отразится в выводе вашей программы.

10. Синтаксис JSON и XML;
JSON синтаксис более компактный, чем у XML. JSON синтаксис легче читать и писать.
Синтаксис JSON позволяет легко определять объекты, в отличие от более многословного способа работы с массивами или коллекциями в синтаксисе XML.
Также важно помнить, что синтаксис для XML сложнее, чем для JSON из-за необходимости ссылок на сущности, которые могут не понадобиться в некоторых случаях
(например, если вы создаете API-сервис). XML не является человекочитаемым. Читать JSON гораздо легче, чем XML, потому что в JSON используется меньше символов,
что облегчает понимание смысла данных. JSON более лаконичен. В нем используется меньше символов для представления той же информации, что и в XML.

11. В JSON и XML тип данных значения кодируется как объект или элемент. В JSON в качестве типов данных поддерживаются только строки, числа, булевы и null.
С другой стороны, в данных XML для описания данных XML могут использоваться многие другие типы, например, дата и время.


10. Опишите что будет происходить «под капотом» после ввода адреса сайта в браузере и нажатия Enter?
1. Пользователь вводит в браузере адрес сайта

2. Браузер начинает искать сервер. За работу любого сайта обычно отвечает один из миллионов серверов, подключенных к интернету.
Адрес сервера — это уникальный набор цифр, который называется IP-адресом.
Поэтому первым делом браузеру нужно понять, какой IP-адрес у сервера, на котором находится сайт.
Такая информация хранится в распределенной системе серверов — DNS (Domain Name System). Система работает как общая «контактная книга», хранящаяся на распределенных серверах и устройствах в интернете.
Однако перед тем, как обращаться к DNS, браузер пытается найти запись об IP-адресе сайта в ближайших местах, чтобы сэкономить время:
Сначала в своей истории подключений. Если пользователь уже посещал сайт, то в браузере могла сохраниться информация c IP-адресом сервера.
В операционной системе. Не обнаружив информации у себя, браузер обращается к операционной системе, которая также могла сохранить у себя DNS-запись.
Например, если подключение с сайтом устанавливалось через одно из установленных на компьютере приложений.
В кэше роутера, который сохраняет информацию о последних соединениях, совершенных из локальной сети.

3. Браузер отправляет запрос к DNS-серверам. Не обнаружив подходящих записей в кэше, браузер формирует запрос к DNS-серверам, расположенным в интернете.
Запрос переадресовывается дальше, на сервер «выше», пока в итоге один из серверов не найдет ответ об IP-адресе для сайта.

4. Браузер устанавливает соединение с сервером. Как только браузер узнал IP-адрес нужного сервера, он пытается установить с ним соединение.
В большинстве случаев для этого используется специальный протокол — TCP. TCP — это набор правил, который описывает способы соединения между устройствами,
форматы отправки запросов, действия в случае потери данных и так далее.

5. Браузер отправляет HTTP-запрос, чтобы получить контент сайта. После установки соединения браузер отправляет специальный запрос,
в котором просит сервер отправить данные для отображения страницы. В этом запросе содержится информация о самом браузере, временные файлы,
требования к соединению и так далее. Задача браузера — как можно подробнее объяснить серверу, какая именно информация ему нужна.
В общении браузера и сервера выделяют два типа запросов. GET-запрос используется для получения данных с сервера — например, отобразить картинку, текст или видео.
POST-запрос — используется для отправки данных из браузера на сервер, например, когда пользователь отправляет сообщение, картинку или загружает файл.
Почти все сайты обмениваются информацией с сервером в зашифрованном формате — с помощью HTTPS-протокола.
В отличие от HTTP-протокола, в HTTPS используется шифрование, а безопасность подключения подтверждается специальным сертификатом.

6. Сервер обрабатывает запрос. Сервер получил запрос от браузера с подробным описанием того, что ему требуется. Теперь ему нужно обработать этот запрос.
Этой задачей занимается специальное серверное программное обеспечение — например, nginx или Apache. Чаще всего такие программы принято называть веб-серверами.
Веб-сервер в свою очередь перенаправляет запрос на дальнейшую обработку к программе-обработчику — например, PHP, Ruby или ASP.NET.
Программа внимательно изучает содержимое запроса — например, понимает, в каком формате нужно отправить ответ и какие именно файлы нужны. И собирает ответ.

7. Сервер отправляет ответ браузеру. Когда ответ сформирован, он отправляется веб-сервером обратно браузеру. В ответе как правило содержится контент для отображения веб-страницы,
информация о типе сжатия данных, способах кэширования, файлы cookie, которые нужно записать и так далее.
Чтобы обмен данными был быстрым, браузер и сервер обмениваются сразу множеством небольших пакетов данных — как правило, в пределах 8 КБ.
Все пакеты имеют специальные номера, которые помогают отслеживать последовательность отправки и получения данных.

8. Браузер обрабатывает полученный ответ и «рисует» веб-страницу. Браузер распаковывает полученный ответ и постепенно начинает отображать полученный контент
на экране пользователя — этот процесс называется рендерингом. Сначала браузер загружает только основную структуру HTML-страницы. Затем последовательно проверяет
все теги и отправляет дополнительные GET-запросы для получения с сервера различных элементов — картинки, файлы, скрипты, таблицы стилей и так далее.
Поэтому по мере загрузки страницы браузер и сервер продолжают обмениваться между собой информацией. Параллельно с этим на компьютер как правило сохраняются
статичные файлы пользователя — чтобы при следующем посещении не загружать их заново и быстрее отобразить пользователю содержимое страницы.
Как только рендеринг завершен — пользователю отобразится полностью загруженная страница сайта.


